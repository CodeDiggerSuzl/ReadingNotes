# 码出高效 Java 开发手册

## 1. 计算机基础

- 计算机表示负数: 8 条电路，对应一位。最左侧表示正负，0+ ，1-。不参与数值表示。最大值 `01111111`, 即 127 .
- 二进制最终以补码形式表示,
  - 正数, 原码和反码一样
  - 负数补码是反码加以的结果
- 才能使得减法运算使用加法器实现. 符号位也参与运算。

一条电路对应 1 位 (bit)

8 bit     --> Byte |
1024 Byte --> 1KB  |
1024 KB   --> 1MB  |
1024 MB   --> GB   |

### 位运算

### 移位运算
浮点数

### CPU 和内存
- **cpu**
  - 控制器
  - 运算器
  - 寄存器


### TCP/IP 协议
Transmission Control Protocol/ Internet Protocol 控制传输协议 / 因特网协议

**TCP 分层 **
- 链路层

端口 ? IP 地址? MAC 地址
- **IP 协议 **
  - ** 面向无连接 **, ** 无状态的 **, 没有额外的机制保证发送的包是否有序到达.
- **TCP 协议建立 **
  - ** 面向连接 **, 确保数据在端到端可靠的传输协议.

秒级 SQL 查询提升空间
1. 建立高效合适的索引
2. 排查链接资源未显式关闭的情形.
3. 合并短请求
4. 合理拆分多个表 join 的 SQL, 超过三个表禁止 join.
5. 使用临时表.
6. 应用层优化.
7. 使用其他数据库
### 信息安全
肉鸡
#### 完整安全体系 CIP 原则
- Confidentiality 保密性
- Integrity 完整性
- Availability  可用性
#### 常见攻击
- SQL 注入
- XSS  Cross-Site  Scripting
  - 反射性
  - 储存性
  - DOM 性
  - Self-XSS
- CSRF Cross-Site  Request  Forgery

### CSRF 和 XSS 区别
#### HTTPS  HTTP over SSL
SSL: Secure Socket Layer, SSL 安全套接字层

- 对称算法: 主站和用户使用相同的密钥对传输内容进行解密. 如 DES 并不是完全没有风险.
- 非对称算法: RSA 公钥和私钥  这种安全性基于大质数分解的困难性, 非对称算法中公钥和私钥是一对大质数函数. 计算乘积简单, 但是分解质数很困难.

这种方法也不是很完美, 缺点是加密和解密时间耗费时间长. 只适合对少量的数据进行处理.

- 冯诺依曼计算机体系: 运算器 控制器 储存器 输入设备 输出设备

## 2. 面向对象
### 抽象
找到属性和行为的共性, 属性是行为的基本生产资料, 具有危险性, 不能随便暴露.

封装主要的任务为: 对属性, 数据, 部分内部敏感行为实现进行隐藏. 减低耦合 :)
### 封装
### 继承
- 方法污染
- 方法爆炸
### 多态
以上述三个面向对象为基础,** 根据运行时的实际对象类型 **, 同一个方法产生不同的运行效果, 使一个行为具有不同的表现形式.

override 垂直方向上的行为的不同体现.
overload 水平方向上行为的不同的体现.

## Java
### 类
分类: class interface enum
组成: 成员和方法

### 接口和抽象类
接口和抽象类共同点: 不能被实例化, 但是可以引用变量指向实例对象.
抽象类: is-a
接口: can-do

- 内部类: 编译后的 `.class` 文件 格式 ` 外部类 $ 内部类 `

变量就像是自己的小孩, 尽量控制在自己的视野范围内, 作用域太大, 无限制乱跑, 就会担心安危.

// TODO: 类图: page 63
- 空心三角形表示继承
- 空心菱形表示聚合
- 空心菱形表示聚合

### 序列化
内存中的数据对象转化为二进制流的过程称为序列化. 反之叫反序列化.
常用作 RPC 框架中数据传输

1. Java 原生序列化

   实现 `Serializable` 接口. 不支持跨语言, 性能一般. 设置 `serialVersionUID` 字段值, 不设置会自动生成, 重新编译后会重新生成. 不推荐使用原生序列化.
2. Hessian 序列化. 支持动态类型 / 跨语言 / 基于对象的网络传输协议. 特性:
   1. 自描述序列化协议, 不依赖外部描述文件和接口.
   2. 跨语言
   3. 协议简单, 比 Java 高效.
   4. 会将复杂对象的所有属性序列化到 map 中进行序列化. 在父类 / 子类存在同名成员变量情况下, 会先序列化子类, 在序列化父类. 反序列化的时候回导致子类同名方法被父类的值覆盖.
3. JSON (JavaScript Object Notation)

   就是将数据对象转化为 JSON 字符串, 在序列化中抛弃了类型信息, 在反序列化的时候只有提供类型信息才能准确的进行序列化.

   在进行网络传输的时候, 由于对象中有敏感的数据, 会造成黑客的攻击. 有些对象的敏感信息不需要进行序列化传输的时候, 可以加 `transient` 关键字, 可以避免将此属性信息转化为二进制流. 如果一定要传递敏感信息, 可以使用对称和非对称加密方法独立传输, 在使用某种方法把属性还原到对象中.
### 方法
 ** 方法签名:** 方法签名包括 ** 方法名称 ** 和 ** 参数类别 **, 是 JVM 表示方法的唯一索引, 不包括返回值, 权限控制符, 异常类型等.
 TODO

 可变参数: 谨慎使用使用, 尽量不要用. 一定要使用的话:

 1. 只用相同的参数类型, 形同业务参数才可以.
 2. 一个方法中只能有一个可变参数, 这个可变参数必须是最后一个参数.
 3. 不要使用 `Object` 作为可变参数 (类型转换不好判断, 过与灵活)

正确使用参数:

1. 入参保护

   实质上是对服务方的保护常见于批量接口.
2. 参数校验

    需要校验的场景:
    1. 调用频率低的方法
    2. 执行时间开销大的方法
    3. 极高稳定性和可用的性的方法
    4. 对外提供的开发接口
    5. 敏感权限的入口

    不需要进行参数校验的方法:
    1. 极有可能循环调用的方法
    2. 底层调用的方法
    3. 声明为 `private` 只会被自己调用的方法



构造方法: 与方法名和类名相同的方法, 特征如下:
1. 构造方法名和类名相同
2. 没有返回值 (即使是 `void`)  返回对象的地址, 赋值给引用变量
3. 不能被继承 / 覆写 / 直接调用. 通过
   1. `new` 关键字
   2. 子类中构造方法中使用 `super` 调用父类的构造方法
   3. 反射
4. 类定义是提供默认的无参构造方法
5. 构造方法可以私有

    接口中不能定义构造方法, 抽象类中可以定义. 枚举中可以定义, 但是不能加 `public` 默认是 `private` 的, 绝对的单例, 不能外部以创建对象的方式生成枚举对象.

    类中可以有多个构造方法. 应该写在一起, 方便阅读.

    构造方法就是在构造对象的时候进行传参, 不应该在构造方法中引入业务逻辑.

    **`static{...}`**: 静态代码块: 创建类的对象时候, 会先执行父类和子类的静态代码块, 在执行父类和子类的构造方法. 静态代码块只执行一次, 第二次实例化的时候, 不会运行. 不是执行完父类的静态代码块和构造方法后, 在执行子类的静态代码块和构造方法.
6. 类内方法: 某些方法归属于具体对象, 类内方法.

   构造方法无论是有形 / 无形 / 私有共有, 在一个类中是必然存在的.

    类中还有三类方法: 实例方法 / 静态方法 / 静态代码块.
    1. 实例方法 (非静态方法)

        必须依附于某个实际的对象, 可以通过引用变量调用其方法. 类内部的实例方法可以相会调用, 可以直接读写类内变量, 但是不包含 `this`. 当 `.class` 字节码文件加载后, 实例方法不会被分配方法入口地址,** 只有在对象创建后才会被分配.** 实例方法可以调用静态变量和静态方法, 外部创建对象后, 尽量使用 ` 类名. 静态方法 ` 来调用, 不是对象名, 一来为编译器减负, 二是提升代码可读性.
    2. 静态方法 (类方法)

        类加载后, 分配相应的内存空间. 注意:
        1. 静态方法中不能使用实例变量和实例方法;
        2. 不能使用 `super` 和 `this` 关键字, 这两个关键字代指的都是 ** 需要被创建出来的对象 **.

        通常定义在工具类中的方法, 静态方法如果使用了可以修改的对象, 那么并发是时候会存在线程安全的问题, 所以工具类的静态方法通常使用单例.

    3. 静态代码块

        在类加载的时候就被调用, 并且只执行一次. 是先于构造方法执行的特殊代码块.

        不存在于任何方法体内, 包括静态方法和属性变量.

        静态方法和静态变量之间没有先后关系.

        可以使用静态代码块来实现类加载判断, 属性初始化, 环境配置等.
    4. `getter` 和 `setter`

        不包含业务方法, 仅仅为类成员属性提供读取和修改的方法. 好处如下:

        1. 面向对象语言的封装特性.
        2. 统一的控制

        注意:

        1. `getter` 和 `setter`r 中不要加业务逻辑
        2. 不要同时定义 `isXXX` 和 `getXXX` 方法
        3. 避免相同的属性名



#### 同步和异步

| 同步 | 刚性调用 | 阻塞式操作 | 必须等待方法体执行结束                                                        |
| :--- | :------- | ---------- | :---------------------------------------------------------------------------- |
| 异步 | 柔性调用 | 非阻塞操作 | 执行过程中, 如果调用其他方法, 自己可以继续执行而不被阻塞等待方法调用调用完毕. |

异步调用通常用在某些耗时长的操作上，这个耗时时间长的操作上，这个耗时时间长的方法的返回结果，可以使用某种 ** 反向通知机制 **，或者在启动一个线程轮询。

1. 反向通知需要异步系统和各个调用它的系统进行耦合
2. 轮询会对于没有执行完的任务会不断的请求，会加大执行机器的压力、

异步处理任务是 ** 非时间敏感的 **。

-----
#### `override` 重写 覆写

父类方法定义达不到子类的期望, 子类可以重新实现方法覆盖父类的实现.

因为有些子类是延迟加载, 或者是网络加载加载, 最终实现需要在运行期判断, 这就是 ** 动态绑定 **。

> 动态绑定是多态实现的重要因素，* 元空间 (TODO)* 有一个方法表保存着每个可以实例化类的方法信息，jvm 可以通过方法表快速的激活实例方法，如果某个类重写了父类的某个方法，则方法表中的方法指向子类的实现处。

常用代码如下, 父类调用子类方法, 叫做 ** 向上转型 **.
```java
Father father = new Son();
father.doSomething();
```
注意:
1. 无法调用子类中存在父类本身不存在的方法.
2. 可以调用到子类中覆写了父类的方法, 这是一种多态的实现.

覆写父类方法成功的条件:
1. 访问权限不能变小
2. 返回类型能够向上转型成为父类的返回类型.

    覆写时, 父类的方发表指向了子类实现方法, 编译器会检查返回值是否向上兼容. 这里的向上转型必须是严格的继承关系。数据类型基本不存在通过继承向上转型的问题。
3. 异常也要向上转型称为父类法方法。

    异常分为 `checked` 和 `unchecked` 两种.
4. 方法名、参数类型、和个数必须完全一致。

方法覆写可以总结成：** 一大一小两同 **
- 一大：子类的方法访问权限控制符只能相同或者变大
- 两小：抛出异常和返回值只能变小，能够转型称为父类对象。子类的返回值，抛出异常类型必须与父类的返回值、抛出异常类型必须与父类的异常返回值、抛出异常类型存在继承关系。
- 两同：方法名和参数完全相同。

覆写只能针对 非静态 | 非 final | 非构造方法。

#### 重载
一个类中，多个方法有相同名字、不同参数，就称为重载。

在编译器中：** 方法签名 + 参数类型 + 参数个数组成唯一键，称为方法签名 **，JVM 通过这个唯一键决定调动哪种重载方法。

JVM 在重载方法中，选择合适目标顺序为：
1. 精确匹配
2. 如果为基本数据类型，自动转换成表示范围更大的基本类型

    `method(long)`,` 可以接受 method(3)`

    基本数据类型转化为范围更大的基本数据类型优先于自动壮装箱：即 `int` 转化为 `long` 优先于 `Integer`。
3. 通过自动拆箱和自动装箱
4. 通过子类向上转型继承路线以此匹配
5. 通过可变参数匹配

### 泛型
泛型的本质是：类型参数化，解决不确定具体对象类型关系。

可以定义在 类、接口、方法中。编译器通过识别 `<>` 和尖括号中字母来解析泛型。

约定的符号
- `E` Element 用于集合中的元素
- `T` the type of object 表示某个类
- `K` key       `V` value

注意点
- 尖括号中的每个元素都代指一种未知类型, String 出现在尖括号中, 就不是 `java.lang.String` 而是一个代号.
- ** 尖括号的位置必须在: 类名之后和方法返回值之前 **
- 泛型在定义处只具备执行 `Object` 方法的能力, 泛型只能调用 `Object` 类中的方法
- ** 泛型只是一种编写代码时的语法检查 **

    使用泛型元素时, 会强制进行类型转换, 这就是 ** 类型擦除 **.(TODO)

- 使用泛型的好处
  - 类型安全
  - 提升可读性
  - 代码重构

### 数据类型
#### 基本数据类型
特征:
- 不具备对象的特性, 没有属性和行为.
- 不能再分的原子数据类型
- 内存中直接存放此类型的值, 可以直接通过内存地址访问到这个数据, 能存区域中只能存放这种类型的值

4 类 8 种

引用分为两种数据类型: 引用变量本身 (Reference Variable `refvar`) 和引用指向的对象(Referred Object `refobj`).
- refvar, 是基本数据类型, 默认值为 `null`, 储存的是 `refobj` 的首地址 (TODO), 可以使用 `==` 进行等值判断. 平时使用 `refvar.hashCode()` 返回的值, 只是对象的某种哈希计算, 可能和地址有关,**与`refvar`本身储存的内存单元地址是两回事**.
- refvar 作为引用变量,无论是指向包装类、集合类、字符串类、还是自定义类均占用 4B 空间.
- 无论 `refboj`是多小的对象最小占用空间是12B,(用来储存基本信息,称为对象头)但是由于必须为8B的倍数,所以初始分配空间至少为16B.

一个refvar最多储存一个refobj的首地址,一个refobj可以被多个refvar储存下它的首地址,即一个堆对象可以被多个refvar引用指向.如果refboj没有被任何refvar执行,那么它迟早会被垃圾回收. refvar的内存使用,与其他基本数据类型类似.

